// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: tracks.sql

package database

import (
	"context"
	"time"
)

const addTrack = `-- name: AddTrack :exec
INSERT INTO "tracks" (
  "id",
  "artist",
  "name",
  "genre",
  "bpm",
  "key",
  "created",
  "updated"
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type AddTrackParams struct {
	ID      string
	Artist  string
	Name    string
	Genre   string
	BPM     float64
	Key     string
	Created time.Time
	Updated time.Time
}

func (q *Queries) AddTrack(ctx context.Context, arg AddTrackParams) error {
	_, err := q.db.Exec(ctx, addTrack,
		arg.ID,
		arg.Artist,
		arg.Name,
		arg.Genre,
		arg.BPM,
		arg.Key,
		arg.Created,
		arg.Updated,
	)
	return err
}

const getMostPlayedTracks = `-- name: GetMostPlayedTracks :many
SELECT
  tracks.id, tracks.artist, tracks.name, tracks.genre, tracks.bpm, tracks.key, tracks.created, tracks.updated, tracks.fts_name_and_artist,
  count("tracks"."id") as "played"
FROM "tracks"
JOIN "tracklist_tracks" ON "tracklist_tracks"."track_id" = "tracks"."id"
GROUP BY "tracks"."id"
ORDER BY "played" DESC
LIMIT $1
`

type GetMostPlayedTracksRow struct {
	Track  Track
	Played int64
}

func (q *Queries) GetMostPlayedTracks(ctx context.Context, limit int32) ([]*GetMostPlayedTracksRow, error) {
	rows, err := q.db.Query(ctx, getMostPlayedTracks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostPlayedTracksRow{}
	for rows.Next() {
		var i GetMostPlayedTracksRow
		if err := rows.Scan(
			&i.Track.ID,
			&i.Track.Artist,
			&i.Track.Name,
			&i.Track.Genre,
			&i.Track.BPM,
			&i.Track.Key,
			&i.Track.Created,
			&i.Track.Updated,
			&i.Track.FtsNameAndArtist,
			&i.Played,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrack = `-- name: GetTrack :one
SELECT
  "id",
  "artist",
  "name",
  "genre",
  "bpm",
  "key",
  "created",
  "updated"
FROM "tracks"
WHERE "id" = $1
LIMIT 1
`

type GetTrackRow struct {
	ID      string
	Artist  string
	Name    string
	Genre   string
	BPM     float64
	Key     string
	Created time.Time
	Updated time.Time
}

func (q *Queries) GetTrack(ctx context.Context, id string) (*GetTrackRow, error) {
	row := q.db.QueryRow(ctx, getTrack, id)
	var i GetTrackRow
	err := row.Scan(
		&i.ID,
		&i.Artist,
		&i.Name,
		&i.Genre,
		&i.BPM,
		&i.Key,
		&i.Created,
		&i.Updated,
	)
	return &i, err
}

const getTrackByArtistAndName = `-- name: GetTrackByArtistAndName :one
SELECT
  "id",
  "artist",
  "name",
  "genre",
  "bpm",
  "key",
  "created",
  "updated"
FROM "tracks"
WHERE "artist" = $1 AND "name" = $2
LIMIT 1
`

type GetTrackByArtistAndNameParams struct {
	Artist string
	Name   string
}

type GetTrackByArtistAndNameRow struct {
	ID      string
	Artist  string
	Name    string
	Genre   string
	BPM     float64
	Key     string
	Created time.Time
	Updated time.Time
}

func (q *Queries) GetTrackByArtistAndName(ctx context.Context, arg GetTrackByArtistAndNameParams) (*GetTrackByArtistAndNameRow, error) {
	row := q.db.QueryRow(ctx, getTrackByArtistAndName, arg.Artist, arg.Name)
	var i GetTrackByArtistAndNameRow
	err := row.Scan(
		&i.ID,
		&i.Artist,
		&i.Name,
		&i.Genre,
		&i.BPM,
		&i.Key,
		&i.Created,
		&i.Updated,
	)
	return &i, err
}

const getTracksByQuery = `-- name: GetTracksByQuery :many
SELECT
  "id",
  "artist",
  ts_headline("artist", "q", 'StartSel=<<, StopSel=>>') as "artist_highlighted",
  "name",
  ts_headline("name", "q", 'StartSel=<<, StopSel=>>') as "name_highlighted",
  "genre",
  "bpm",
  "key",
  "created",
  "updated"
FROM (
  SELECT
    "id",
    "artist",
    "name",
    "genre",
    "bpm",
    "key",
    "created",
    "updated",
    ts_rank("fts_name_and_artist", "q") as "rank",
    "q"
  FROM "tracks", websearch_to_tsquery($1::text) "q"
  WHERE "fts_name_and_artist" @@ "q"
  ORDER BY "rank" DESC
) as "searched_tracks"
ORDER BY "rank" DESC
LIMIT $2::int
`

type GetTracksByQueryParams struct {
	Query    string
	RowLimit int32
}

type GetTracksByQueryRow struct {
	ID                string
	Artist            string
	ArtistHighlighted []byte
	Name              string
	NameHighlighted   []byte
	Genre             string
	BPM               float64
	Key               string
	Created           time.Time
	Updated           time.Time
}

func (q *Queries) GetTracksByQuery(ctx context.Context, arg GetTracksByQueryParams) ([]*GetTracksByQueryRow, error) {
	rows, err := q.db.Query(ctx, getTracksByQuery, arg.Query, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTracksByQueryRow{}
	for rows.Next() {
		var i GetTracksByQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Artist,
			&i.ArtistHighlighted,
			&i.Name,
			&i.NameHighlighted,
			&i.Genre,
			&i.BPM,
			&i.Key,
			&i.Created,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
